[{"content":"TBD\n","date":"18 January 2024","permalink":"/authors/ansilh/","section":"Authors Taxonomy Listing Example","summary":"TBD","title":"Ansil H"},{"content":"A quick example of how to start using author taxonomies in your articles.\n","date":"18 January 2024","permalink":"/authors/","section":"Authors Taxonomy Listing Example","summary":"A quick example of how to start using author taxonomies in your articles.","title":"Authors Taxonomy Listing Example"},{"content":"","date":"18 January 2024","permalink":"/tags/ebpf/","section":"Tags","summary":"","title":"ebpf"},{"content":"","date":"18 January 2024","permalink":"/series/ebpf/","section":"Series","summary":"","title":"eBPF"},{"content":"In the previous article, we wrote an eBPF program to block all packets via XDP.\nThis article is a continuation of previous artcle where we will block a TCP port of an interface instead of all packets.\nBut before we go forward, let\u0026rsquo;s expand the diagram we have see in the first article.\nThe BPF or pseudo VM has been enhanced by Alexei Starovoitov along with Daniel Borkmann.\nRegistres were increased from 3 to 11. Changed register to 64bit. Added a stack of 512 bytes Added unlimited arbitory key/value structure called maps Added helper function support Added a Verifier to verify code Added a JIT compiler to generate native assembly code from object code A simple firewall using eBPF # This eBPF program will will block traffic to port 80 of an interface.\n#include \u0026lt;linux/bpf.h\u0026gt; #include \u0026lt;bpf/bpf_helpers.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;linux/if_ether.h\u0026gt; #include \u0026lt;linux/ip.h\u0026gt; #include \u0026lt;linux/tcp.h\u0026gt; #define BLOCK_PORT 80 #define TOTSZ (sizeof(struct ethhdr) + sizeof(struct iphdr) + sizeof(struct tcphdr)) SEC(\u0026#34;xdp\u0026#34;) int xdp_drop_port(struct xdp_md *ctx) { void *data = (void *)(long)ctx-\u0026gt;data; void *data_end = (void *)(long)ctx-\u0026gt;data_end; // Set IP and TCP header structs struct iphdr *ip = data + sizeof(struct ethhdr); struct tcphdr *tcph = data + sizeof(struct ethhdr) + sizeof(struct iphdr); //Below check is made mandatoy by eBPF verifier if (data + TOTSZ \u0026gt; data_end) { return XDP_PASS; } // If its a TCP packet and destined to port 80, then drop iit if (ip-\u0026gt;protocol == IPPROTO_TCP \u0026amp;\u0026amp; tcph-\u0026gt;dest == htons(BLOCK_PORT)) { // Write debug info to /sys/kernel/debug/tracing/trace_pipe bpf_printk(\u0026#34;Blocking packet from %pI4 to port %u\\n\u0026#34;,\u0026amp;ip-\u0026gt;saddr, ntohs(tcph-\u0026gt;dest)); return XDP_DROP; } return XDP_PASS; } char _license[] SEC(\u0026#34;license\u0026#34;) = \u0026#34;GPL\u0026#34;; We are reading the start and end of data using xdp_md.\nWe have to make sure the headers + data is not greater than the end of the data. If we accedently read anything outside of the end, then that may crash the kernel and that is why the verifier enforces this check.\nOther details are self explanatory from the program itself.\nLet\u0026rsquo;s compile the program and then load it.\nclang -O2 -g -Wall -target bpf -c xdp_drop_port.c -o xdp_drop_port.o sudo xdp-loader load -m skb -s xdp enp0s8 xdp_drop_port.o Then you can watch the trace logs with below command\ncat /sys/kernel/debug/tracing/trace_pipe If you try to use curl command to the IP assigned to the interface enp0s8 then you will notice and output like below;\n\u0026lt;idle\u0026gt;-0 [003] ..s21 89616.096958: bpf_trace_printk: Blocking packet from 192.168.57.1 to port 80 \u0026lt;idle\u0026gt;-0 [003] ..s21 89617.123247: bpf_trace_printk: Blocking packet from 192.168.57.1 to port 80 \u0026lt;idle\u0026gt;-0 [003] ..s21 89619.139545: bpf_trace_printk: Blocking packet from 192.168.57.1 to port 80 Congratulations for making yourself to this stage!!.ðŸŽ‰ Give a pat on your shoulder ðŸ˜„\nSo far we have used eBPF in XDP. In upcoming one, we will use eBPF on kprobs. Brace yourself for the next eBPF chapters.\n","date":"18 January 2024","permalink":"/posts/05-ebpf-for-linux-admins-part5/","section":"Posts","summary":"In the previous article, we wrote an eBPF program to block all packets via XDP.","title":"eBPF for Linux Admins: Part V"},{"content":"","date":"18 January 2024","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"18 January 2024","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"ðŸŽ¤ Speaker at CNCG Kochi, DevOpsMalayalam and AWS Community Days Kochi.\nðŸ‘‰ My Talks\nðŸ‘‰ My Kubernetes Notes\n","date":"18 January 2024","permalink":"/","section":"Welcome to My Blog! ðŸŽ‰","summary":"ðŸŽ¤ Speaker at CNCG Kochi, DevOpsMalayalam and AWS Community Days Kochi.","title":"Welcome to My Blog! ðŸŽ‰"},{"content":"In the previous articles, we were using skb to get details of a packet. This skb object is the kernel representation of a packet.\nDropping a packet after skb gets created is waste of CPU and memory. This can even have an impact during DDoS attempt.\nSo how can we drop a packet even before it reaches the stage of skb creation.\nHere we will use another hook point called XDP or eXpressDataPath. XDP is a high-performance, programmable packet processing framework within the Linux kernel that enables early packet handling before reaching the network stack.\nXDP Packet flow # The packets comes to the NIC. NIC places those packets to the RX_RING which is a circular ring buffer via DMA. When the buffer gets full, an interrupt is fired to CPU. Once the CPU get\u0026rsquo;s interrupted, the loaded NIC driver code gets executed. The driver code reads the packets from the queue. The initial path of packet after RX_RING is where we use XDP. Instead of writing our own module, we will write an eBPF program this time and then attach that to the the interface.\nThere are different ways to us XDP.\nGeneric XDP # XDP program loaded into the kernel as part of the network path.\nNative XDP # XDP program loaded by the driver in it\u0026rsquo;s initial recieve path\nOffloaded XDP # XDP program loads directly to the NIC and handled by the NIC controller.\nIn this article we will use Generic XDP since it doesn\u0026rsquo;t need support from NIC or it\u0026rsquo;s driver.\nOnce the packet is recieved by the XDP progra, it can do one of below;\nXDP_DROP : No processing, just drop the packet.\nXDP_PASS : Pass the packet to the next network stack component.\nXDP_TX : Forward the packet to the same network interface.\nXDP_REDIRECT : Froward the packet to another NIC and bypass all kernel network stack paths.\nAs I mentioned earlier, this is our gateway to eBPF so pay attention to this chapter.\nOur experiments will happen from an Ubuntu 23.10 VM running in VirtualBox.\nYou have been warned!!\nThe eBPF program we write will block all network in an interface. To compile eBPF programs, we need to install few tools.\nsudo apt install clang llvm libelf-dev libpcap-dev build-essential libbpf-dev linux-headers-$(uname -r) gcc-multilib #include \u0026lt;linux/bpf.h\u0026gt; #include \u0026lt;bpf/bpf_helpers.h\u0026gt; SEC(\u0026#34;xdp_drop\u0026#34;) int xdp_drop_prog(struct xdp_md *ctx) { return XDP_DROP; } char _license[] SEC(\u0026#34;license\u0026#34;) = \u0026#34;GPL\u0026#34;; Compile the program to bpf format.\neBPF is restricted to call only a list of kernel helper functions.\nUse man bpf-helpers command to get more details. clang -O2 -g -Wall -target bpf -c xdp_drop.c -o xdp_drop.o After compilation, we will get an eBPF file named xdp_drop.o.\nWe will be using the xdp-loader tool to load the xdp_drop.o program, so we need install xdp tools first.\nsudo apt-get install xdp-tools After installing the tool, check the loaded programs on the interfaces. As of now no programs were laoded!\nsudo xdp-loader status CURRENT XDP PROGRAM STATUS: Interface Prio Program name Mode ID Tag Chain actions -------------------------------------------------------------------------------------- lo \u0026lt;No XDP program loaded!\u0026gt; enp0s3 \u0026lt;No XDP program loaded!\u0026gt; enp0s8 \u0026lt;No XDP program loaded!\u0026gt; enp0s9 \u0026lt;No XDP program loaded!\u0026gt; Now load the program to one of the interface.\nsudo xdp-loader load -m skb -s xdp_drop enp0s8 xdp_drop.o Check the loaded progam on all interfaces.\nsudo xdp-loader status CURRENT XDP PROGRAM STATUS: Interface Prio Program name Mode ID Tag Chain actions -------------------------------------------------------------------------------------- lo \u0026lt;No XDP program loaded!\u0026gt; enp0s3 \u0026lt;No XDP program loaded!\u0026gt; enp0s8 xdp_dispatcher skb 117 90f686eb86991928 =\u0026gt; 50 xdp_drop_prog 126 57cd311f2e27366b XDP_PASS enp0s9 \u0026lt;No XDP program loaded!\u0026gt; That concludes part 4 of this eBPF series. In next one we will see how to block a port using eBPF in XDP.\n","date":"14 January 2024","permalink":"/posts/04-ebpf-for-linux-admins-part4/","section":"Posts","summary":"In the previous articles, we were using skb to get details of a packet.","title":"eBPF for Linux Admins: Part IV"},{"content":"In this article, we will write a kernel module that drops the incoming packets if it\u0026rsquo;s destined to port 80.\nYes, we can use iptables, but to learn the innerworkings of Linux, let\u0026rsquo;s come out of that confort zone and write our own one this time. Before we move forward, we have to familiarise more terms, which are Helper Functions and Hooks.\nHelper Functions # In the previous chapter, we wrote a simple module to print a message to the kernel ring buffer and there we used a helper function called, pr_info.\nSince the driver is in Kernel space, we couldn\u0026rsquo;t use any of the userpsace libraries to make log entries. So what we did was, we tooke the help of a kernel helper function. Linux helper functions are facilites that can be used to interact with other parts of the kernel. We will see more helper functions going forward.\nIn our hello example we used the helper function pr_info from header file \u0026lt;linux/printk.h\u0026gt;\nHooks # Hooks are pre-defined points in Kernel where you can register a function to it. When ever kernel reaches that hook, the registred function in that hook gets executed.\nLet\u0026rsquo;s see an example of hooks in netfilter. What is netfilter?\nIt\u0026rsquo;s your favorite iptables/nftable backend to filter/tralslate packets.\nThe netfilter hooks are a framework inside the Linux kernel that allows kernel modules to register callback functions at different locations of the Linux network stack. The registered callback function is then called back for every packet that traverses the respective hook within the Linux network stack. In above diagram, you can see different hook points and we will use the hook point PRE-ROUTING to drop a packet. So, we will write a module that will have a function; to be precise a callback function, to drop an IPv4 packet if the destination port is 80. Then that function will be registed to the PRE-ROUTING hook. When ever the kernel reaches the PRE-ROUTING hook point, our function will get executed and packet will be dropped.\nBut wait!!. Didn\u0026rsquo;t we start this series for learning eBPF? Yeah, I know, but please be patient. Things will get better going formward.\nA simple firewall module to drop packets to port 80 # mkdir -p netfilter/example cd !$ vi drop_pkt.c #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/ip.h\u0026gt; #include \u0026lt;linux/tcp.h\u0026gt; #include \u0026lt;linux/netfilter.h\u0026gt; #include \u0026lt;linux/netfilter_ipv4.h\u0026gt; #define BLOCK_PORT 80 // Callback function static unsigned int hook_func(void *priv, struct sk_buff *skb, const struct nf_hook_state *state) { // Access packet information using skb struct iphdr *iph = ip_hdr(skb); struct tcphdr *tcph = tcp_hdr(skb); if(ntohs(tcph-\u0026gt;dest) == BLOCK_PORT){ pr_info(\u0026#34;Blocking packet from %pI4 to port %u\\n\u0026#34;,\u0026amp;iph-\u0026gt;saddr, ntohs(tcph-\u0026gt;dest)); return NF_DROP; // Drop packets to port 80 } return NF_ACCEPT; // Allow the packet to continue } // Netfilter hook options static struct nf_hook_ops nf_hook_ops = { .hook = hook_func, // Our callback function .pf = PF_INET, // IPv4 protocol family .hooknum = NF_INET_PRE_ROUTING, // Hook point in the netfilter framework .priority = NF_IP_PRI_FIRST, // Invocation priority }; static int __init drop_pkt_module_init(void) { return nf_register_net_hook(\u0026amp;init_net, \u0026amp;nf_hook_ops); //init_net indicates the root network namespace } static void __exit drop_pkt_module_exit(void) { nf_unregister_net_hook(\u0026amp;init_net, \u0026amp;nf_hook_ops); } module_init(drop_pkt_module_init); module_exit(drop_pkt_module_exit); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); Create a Makefile with below contnents.\nvi Makefile obj-m += drop_pkt.o PWD := $(CURDIR) all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean Now, you can start a simple HTTP server using python in a new terminal.\nsudo python3 -m http.server 80 Now try to access the port using curl command.\ncurl -sI 192.168.56.102 Output:-\nHTTP/1.0 200 OK Server: SimpleHTTP/0.6 Python/3.10.12 Date: Mon, 15 Jan 2024 17:38:36 GMT Content-type: text/html; charset=utf-8 Content-Length: 1218 Now, load the module.\ninsmod drop_pkt.ko Repeat the curl command again and this time the command will hung.\nIf you check the dmesg, you will see and output like below;\n... [98510.008817] Incoming packet from 192.168.56.1 to port 80 [98511.022603] Incoming packet from 192.168.56.1 to port 80 [98513.038433] Incoming packet from 192.168.56.1 to port 80 [98517.198138] Incoming packet from 192.168.56.1 to port 80 ... You can unload the module using below command and then curl command will work.\nsudo rmmod drop_pkt Now we are familier with how we can interact with different parts of the kernel using Kernel modules and some of the basics of hooks and helper functions.\nIn the next one, we will learn how we can inetract with the packets before the kernel create socket buffer or skb.\n","date":"5 January 2024","permalink":"/posts/03-ebpf-for-linux-admins-part3/","section":"Posts","summary":"In this article, we will write a kernel module that drops the incoming packets if it\u0026rsquo;s destined to port 80.","title":"eBPF for Linux Admins: Part III"},{"content":"You might be wondering, why we have to look at wrting kernel modules. The idea of kernel modules will help you to breakdown some of the key flexbilities in Linux kernel.\nPlease refer the book The Linux Kernel Module Programming Guide for more info. Its a FREE book. The Hello world module # This module will print messages to the kernel ring buffer (is special datastructure in kernel) and we can read those message using dmesg command.\nLet\u0026rsquo;s create a directory for our module and start writing our code.\nmkdir -p lkmpg/hello-world cd !$ vi hello.c Paste below contents to the editor and save it.\n/* * hello.c - The simplest kernel module. */ #include \u0026lt;linux/module.h\u0026gt; /* Needed by all modules */ #include \u0026lt;linux/printk.h\u0026gt; /* Needed for pr_info() */ int init_module(void) { pr_info(\u0026#34;Hello world 1.\\n\u0026#34;); /* A non 0 return means init_module failed; module can\u0026#39;t be loaded. */ return 0; } void cleanup_module(void) { pr_info(\u0026#34;Goodbye world 1.\\n\u0026#34;); } MODULE_LICENSE(\u0026#34;GPL\u0026#34;); Create a Makefile to compile the code.\nvi Makefile obj-m += hello.o PWD := $(CURDIR) all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean Now, let\u0026rsquo;s compile the code and load it.\nmake Output:-\nmake -C /lib/modules/6.2.0-39-generic/build M=/home/ansil/lkmpg/hello-world modules make[1]: Entering directory \u0026#39;/usr/src/linux-headers-6.2.0-39-generic\u0026#39; warning: the compiler differs from the one used to build the kernel The kernel was built by: x86_64-linux-gnu-gcc-11 (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0 You are using: gcc-11 (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0 CC [M] /home/ansil/lkmpg/hello-world/hello.o MODPOST /home/ansil/lkmpg/hello-world/Module.symvers CC [M] /home/ansil/lkmpg/hello-world/hello.mod.o LD [M] /home/ansil/lkmpg/hello-world/hello.ko BTF [M] /home/ansil/lkmpg/hello-world/hello.ko Skipping BTF generation for /home/ansil/lkmpg/hello-world/hello.ko due to unavailability of vmlinux make[1]: Leaving directory \u0026#39;/usr/src/linux-headers-6.2.0-39-generic\u0026#39; Load the module\nsudo insmod hello.ko Now execute dmesg command to see the output\nsudo dmesg | tail Output:-\n... [ 3544.575680] Hello world 1. ... Let\u0026rsquo;s unload the module and confirm the message again.\nList the loaded module lsmod | grep hello Unload the module sudo rmmod hello Now you can execute dmesg command again to verify the message.This time you can see the \u0026ldquo;Goodbye\u0026rdquo; message.\n... [ 3544.575680] Hello world 1. [10666.570524] Goodbye world 1. ... This covers the part II of the eBPF series. In next one we will write a kernel module to drop a packet.\n","date":"3 January 2024","permalink":"/posts/02-ebpf-for-linux-admins-part2/","section":"Posts","summary":"You might be wondering, why we have to look at wrting kernel modules.","title":"eBPF for Linux Admins: Part II"},{"content":" This article series is based on my journey to demystify eBPF. Pre-requisites # To get the most out of this article, it\u0026rsquo;s helpful to have some background in Linux networking and packet tracing with tcpdump. Some of the internals were intentionally excluded to simplify the topic.\nClassic BPF # Let\u0026rsquo;s take the scenario were you wanted to observe all ARP packet coming to the NIC. The packet first lands in the network device hardware and then later will be placed in an receive queue (RX_RING) inside the Kernel.\nFor a user to see ARP packets, packets needs to be copied from kernel space to the user space. Then each of the packets needs to be filtered based on its packet type; ARP.\nIf the system is going to copy all packets get\u0026rsquo;s into RX_RING to user space and then checking for a matching packet type, system have to do packet copy from kernel space to users pace. Switching CPU from kernel space to user space to copy packet is inefficient and will affect the system performance.\nSo how can we filter packets which are - on-the way - within the kernel space and copy only the matching packets to user space?\nHere comes the BPF or Berkley Packet Filter.\nThe BPF virtual machine is a pseudo VM inside the Linux kernel. For the sake of simplicity, you can consider this as a JavaScript engine inside your browser!\nOne of the tool in Linux that uses BPF is the tcpdump which utilises the BPF for packet filtering.\nThe BPF VM supports a limited set of instructions and there are many restrictions to the usage as well.\nBelow are the registers in BPF VM (or pseudo-machine)\nA 32bit wide accumulator [A] where the contents of the packet get loaded. A 32bit wide index register [X]. A scratch memory area of 16 32bit registers. A program counter. The filters we pass to tcpdump command will be converted into \u0026ldquo;byte code\u0026rdquo; and then injected directly into the kernel.(More about byte code will be coming later in this article.)\nThe load instructions loads the packet data to accumulator, and then we can examine the packets in BPF VM.\nLet\u0026rsquo;s examine the code generated by the tcpdump command that filters the ARP packets coming to interface ens33.\n[root@localhost ~]# tcpdump -i ens33 arp -d (000) ldh [12] (001) jeq #0x806 jt 2 jf 3 (002) ret #262144 (003) ret #0 [root@localhost ~]# Explanation\n(000) ldh - Load half word (16 bits) from index 12 of the packet ; skip 6 byte dst mac and 6 byte src mac. (001) jeq - If accumulator value is 0x806 ; ie ARP packet, then jump to 2 else jump to 3 (002) ret - Return the contents with buffer size 262144 ; ie entire packet or [max snapshot length](https://github.com/the-tcpdump-group/tcpdump/blob/tcpdump-4.9/netdissect.h#L263) (003) ret - Return nothing to the users pace You can find more details of the inner working of BPF in this Usenix paper\nSo the above filter skips the source and destination mac fields and then loads 16bits from the index 12 which is the packet type.\nSo the 16bits - 0x806 (0000100000000110) at offset 12 will try to match ARP packet!\nFew points to note;\nThe Ethernet type II packet have below format; Ethernet packets are big-endain.\nIn a 32bit system, a full word is 32bit, half word is 16bit.\n1 byte = 8bits, 2 byte = 16bits\nYou can find the Ethernet type hex representation of packet types in IANA\n------------------------------------------------------------------------------------------------------------------------------------------------ Ethertype (decimal) Ethertype (hex) Exp. Ethernet (decimal) Exp. Ethernet (octal) Description Reference ------------------------------------------------------------------------------------------------------------------------------------------------ 2054 0806 - - Address Resolution Protocol (ARP) [RFC7042] ------------------------------------------------------------------------------------------------------------------------------------------------ The Byte Code # The BPF program we discussed above can be converted to byte code.\nWhat is byte code?\nA compact, platform-independent instruction set designed for execution by a virtual machine, rather than directly by a physical CPU. In this case the VM is a BPF pseudo VM sitting inside the Kernel.\nThe user space can inject this bytecode to the BPF pseudo VM and the VM will convert that to the architecture dependant assembly code which can be executed directly on the hardware.\nWe can generate the bytecode of the BPF instruction in tcpdump itself.\n[root@localhost ~]# tcpdump -i ens33 arp -ddd 4 40 0 0 12 21 0 1 2054 6 0 0 262144 6 0 0 0 The bytecode can be injected into the system in different ways. The tcmpdump utility have it\u0026rsquo;s own logic to do this operation.\nWith that we concludes the Part - 1 of eBPF for Linux Admins here.\nIn the next part, we will discuss eXpressDataPath - XDP and eBPF.\n","date":"1 January 2024","permalink":"/posts/01-ebpf-for-linux-admins-part1/","section":"Posts","summary":"This article series is based on my journey to demystify eBPF.","title":"eBPF for Linux Admins: Part I"},{"content":" Here goes all the articles I\u0026rsquo;ve published so far.. ","date":"23 December 2023","permalink":"/posts/","section":"Posts","summary":"Here goes all the articles I\u0026rsquo;ve published so far.","title":"Posts"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]