[{"content":"TBD\n","date":"22 January 2024","permalink":"/authors/ansilh/","section":"Authors Taxonomy Listing Example","summary":"TBD","title":"Ansil H"},{"content":"A quick example of how to start using author taxonomies in your articles.\n","date":"22 January 2024","permalink":"/authors/","section":"Authors Taxonomy Listing Example","summary":"A quick example of how to start using author taxonomies in your articles.","title":"Authors Taxonomy Listing Example"},{"content":"","date":"22 January 2024","permalink":"/tags/ebpf/","section":"Tags","summary":"","title":"ebpf"},{"content":"","date":"22 January 2024","permalink":"/series/ebpf/","section":"Series","summary":"","title":"eBPF"},{"content":"In previous chapters, we have seen how XDP and eBPF were used to filter packets.\nNow we will see what is syscall, how we can use kprobes to trace a syscall etc.\nYes, from this chapter onwards, we are not dealing with network. I\u0026rsquo;ve started with network stack so that as a Linux admin you can easily connect the concepts of eBPF.\nHmm.. syscall? The kprobes,syscall,routine,breakpoints etc. are like alien language to me Don\u0026rsquo;t worry, it was same for me too, but we will cover the fundamentals of syscall before we move on to kprobes\nAs a Linux admin, you should know syscall and if not, then this article is for you.\nBelow diagram shows how an application interact with the system. The entrypoint for an application to the kernel space is the syscall interface.\nYou can use the strace command to see the syscalls made by a process.\nUse below command to install strace if it\u0026rsquo;s not installed\nsudo apt-get install strace The below strace command shows the syscall (last column) made by the echo command.\nansil@ebpf:~$ strace -c echo Hello Hello % time seconds usecs/call calls errors syscall ------ ----------- ----------- --------- --------- ---------------- 0.00 0.000000 0 1 read 0.00 0.000000 0 1 write 0.00 0.000000 0 18 close 0.00 0.000000 0 21 mmap 0.00 0.000000 0 3 mprotect 0.00 0.000000 0 1 munmap 0.00 0.000000 0 3 brk 0.00 0.000000 0 2 pread64 0.00 0.000000 0 1 1 access 0.00 0.000000 0 1 execve 0.00 0.000000 0 2 1 arch_prctl 0.00 0.000000 0 1 futex 0.00 0.000000 0 1 set_tid_address 0.00 0.000000 0 30 14 openat 0.00 0.000000 0 17 newfstatat 0.00 0.000000 0 1 set_robust_list 0.00 0.000000 0 1 prlimit64 0.00 0.000000 0 1 getrandom 0.00 0.000000 0 1 rseq ------ ----------- ----------- --------- --------- ---------------- 100.00 0.000000 0 107 16 total ansil@ebpf:~$ To further understand the syscall, let\u0026rsquo;s write a simple C program that will write a line to a file.\nvi sample_write.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main (void) { FILE *fp = fopen (\u0026#34;./sample.txt\u0026#34;, \u0026#34;w\u0026#34;); if (fp != NULL) { if (fprintf (fp, \u0026#34;Random text\\n\u0026#34;) \u0026lt; 0) { fprintf (stderr, \u0026#34;err=%d: %s\\n\u0026#34;, errno, strerror (errno)); fclose (fp); return errno; } fclose (fp); } return 0; } Compile the program.\ngcc sample_write.c -o sample_write You can execute it and see examine the file content.\nansil@ebpf:~$ ./sample ansil@ebpf:~$ cat sample.txt Random text ansil@ebpf:~$ From the user\u0026rsquo;s perspective, the program and the outcomes looks simple, but from a kernel point of view, there is a lot of things in play.\nAs a user, you are creating a file on the disk. The transactions goes through different layers like, the standard library, syscall, virtual file system, the file system driver, the disk driver and finally the disk.\nThe complexity of those interactions were abstracted away for the user by the kernel using syscall interface.\nAs an user, your application will be interacting with the syscall interface and everything else is taken care by the kernel.\nNow, let\u0026rsquo;s see how many syscalls were made by our program.\nansil@ebpf:~$ strace -c ./sample_write % time seconds usecs/call calls errors syscall ------ ----------- ----------- --------- --------- ---------------- 33.54 0.000912 912 1 execve 13.90 0.000378 47 8 mmap 9.64 0.000262 87 3 close 8.16 0.000222 74 3 openat 6.84 0.000186 62 3 mprotect 6.36 0.000173 173 1 munmap 4.30 0.000117 39 3 newfstatat 4.05 0.000110 55 2 pread64 3.38 0.000092 30 3 brk 2.43 0.000066 66 1 write 1.62 0.000044 22 2 1 arch_prctl 1.10 0.000030 30 1 1 access 0.96 0.000026 26 1 getrandom 0.88 0.000024 24 1 read 0.85 0.000023 23 1 prlimit64 0.70 0.000019 19 1 set_robust_list 0.66 0.000018 18 1 set_tid_address 0.63 0.000017 17 1 rseq ------ ----------- ----------- --------- --------- ---------------- 100.00 0.002719 73 37 2 total ansil@ebpf:~$ You can even examine individual calls too. Here I\u0026rsquo;m interested in openat syscall.\nansil@ebpf:~$ strace -e openat ./sample_write openat(AT_FDCWD, \u0026#34;/etc/ld.so.cache\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 openat(AT_FDCWD, \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 openat(AT_FDCWD, \u0026#34;./sample.txt\u0026#34;, O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3 +++ exited with 0 +++ There are 3 openat syscalls, two for loading libraries and the final one for opening our text file sample.txt.\nWe can clearly see the syscall made by our program to read the file in the output.\nNow you know what is syscall and how to trace a program.\nLet\u0026rsquo;s take a scenario where you want to see the openat syscall happening in the system without strace and without even interacting with the program ðŸ¤¯\nIn next chapter, we will discuss how to do it using dynamic tracing with kprobes.\nPlease re-visit if you want to brush up the kernel module concepts.\n","date":"22 January 2024","permalink":"/posts/06-ebpf-for-linux-admins-part6/","section":"Posts","summary":"In previous chapters, we have seen how XDP and eBPF were used to filter packets.","title":"eBPF for Linux Admins: Part VI"},{"content":"Let\u0026rsquo;s look at , kprobes.\nKprobes are one of the dynamic tracing functionality available in Linux Kernel.\nBut why we are learning kprobes and why that is related to eBPF ?\nAs I said earlier, things will get interesting going forward. Please be patient and keep learning\nKprobes enables you to dynamically break into any kernel routine and collect debugging and performance information non-disruptively. You can trap at almost any kernel code address, specifying a handler routine to be invoked when the breakpoint is hit. Read more about kprobes Here is the basic working principle of kprobes\nIdentify the kernel function you want to probe. Register kprobes in that function. The first opcode of the function will be replaced with a break point and the original instruction gets copied. The user defined routine, pre-handler gets called which can inspect all details coming to the original function. Once pre-handler completes the execution, the original instruction that copied earlier gets executed. After the execution, the optional post-handler gets executed which is a user defined routine. Finally the control goes back to the original flow and the next instructions gets executed. Most of our focus will be on pre-handler where we can examine the data coming to the function.\nLet\u0026rsquo;s write a kernel module that probes the function openat and print the program, pid and the file name. We are not going to trace all programs, instead we will trace the function only when the program name matches with sample_write that we wrote earlier.\nLet\u0026rsquo;s write the kprobe module and compile it.\nmkdir -p lkmpg/kprobes cd !$ vi kprobe_example.c #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/kprobes.h\u0026gt; #include \u0026lt;linux/sched.h\u0026gt; static struct kprobe kp = { // The actual function that implements openat syscall // Detailed explanation of this part is at the end of the article. .symbol_name = \u0026#34;do_sys_openat2\u0026#34;, }; static int handler_pre (struct kprobe *p, struct pt_regs *regs) { // we are interested in \u0026#39;sample_write\u0026#39; program we wrote in previous chapter if (strncmp (current-\u0026gt;comm, \u0026#34;sample_write\u0026#34;, 12)) return 0; // Access file name - \u0026#34;man syscall\u0026#34; and look for ABI for more details char *param_fname_reg = (char __user *) regs-\u0026gt;si; // Print the information to \u0026#39;dmesg\u0026#39; printk (\u0026#34;do_sys_openat2 called by:%s pid=%i fname=%s\\n\u0026#34;, current-\u0026gt;comm, current-\u0026gt;pid, param_fname_reg); return 0; } static void handler_post (struct kprobe *p, struct pt_regs *regs, unsigned long flags) { /* Optional handler */ } static int __init kprobe_init (void) { kp.pre_handler = handler_pre; kp.post_handler = handler_post; register_kprobe (\u0026amp;kp); printk (\u0026#34;Kprobe attached to do_sys_openat2\\n\u0026#34;); return 0; } static void __exit kprobe_exit (void) { unregister_kprobe (\u0026amp;kp); printk (\u0026#34;Kprobe detached from do_sys_openat2\\n\u0026#34;); } module_init (kprobe_init); module_exit (kprobe_exit); MODULE_LICENSE (\u0026#34;GPL\u0026#34;); MODULE_AUTHOR (\u0026#34;Ansil H\u0026#34;); MODULE_DESCRIPTION (\u0026#34;Simple Kprobe to trace file open operations from sample_write program\u0026#34;); You might be wondering why we are tracing do_sys_openat2 instead of syscall openat. Long story short, when the openat syscall gets executed, the actual function inside the kernel that is responsible for doing the work is do_sys_openat2. More details are available here if you are interested.\nNow compile the code and load it\nvi Makefile obj-m += kprobe_example.o PWD := $(CURDIR) all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean make Load the module.\nsudo insmod ./kprobe_example.ko Now execute journalctl -f in another terminal and you can see the message Kprobe attached to do_sys_openat2\nJan 22 18:23:19 ebpf sudo[4176]: ansil : TTY=pts/0 ; PWD=/home/ansil/lkmpg/kprobes ; USER=root ; COMMAND=/usr/sbin/insmod ./kprobe_example.ko Jan 22 18:23:19 ebpf sudo[4176]: pam_unix(sudo:session): session opened for user root(uid=0) by ansil(uid=1000) Jan 22 18:23:19 ebpf kernel: Kprobe attached to do_sys_openat2 Jan 22 18:23:19 ebpf sudo[4176]: pam_unix(sudo:session): session closed for user root Good, the module is loaded.\nNow the next step is to execute our sample_write program which we wrote in our previous chapter.\n./sample_write The jounalctl output will show below which indicates that the openat syscall were made 3 time. Two calls were for loading the library and the last one to open our text file sample.txt\nJan 22 18:25:17 ebpf kernel: do_sys_openat2 called by:sample_write pid=4182 fname=/etc/ld.so.cache Jan 22 18:25:18 ebpf kernel: do_sys_openat2 called by:sample_write pid=4182 fname=/lib/x86_64-linux-gnu/libc.so.6 Jan 22 18:25:18 ebpf kernel: do_sys_openat2 called by:sample_write pid=4182 fname=./sample.txt Yay!!! ðŸŽ‰\nNow we know how to write a module that utilizes kprobes to trace a kernel function. Instead of tracing the program (like we did with strace), we traced the kernel function that implements the syscall.!!\nYou can unload the module using below command.\nsudo rmmod kprobe_example The journalctl will show below;\nJan 22 18:28:14 ebpf sudo[4183]: ansil : TTY=pts/0 ; PWD=/home/ansil/lkmpg/kprobes ; USER=root ; COMMAND=/usr/sbin/rmmod kprobe_example Jan 22 18:28:14 ebpf kernel: Kprobe detached from do_sys_openat2 Below topic is completely optional for you, but the understanding of how to navigate Linux kernel source code will make your life easier.\nFinding the function call/symbol of a syscall. # Look at https://elixir.bootlin.com/linux/v6.5/source/include/linux/syscalls.h#L446 for all syscalls.\nThis will show below line.\nasmlinkage long sys_openat(int dfd, const char __user *filename, int flags, Then click on the sys_openat and click on the function definition that points to fs/open.c\nhttps://elixir.bootlin.com/linux/v6.5/source/fs/open.c#L1433\nHere you will see;\nSYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags, umode_t, mode) { if (force_o_largefile()) flags |= O_LARGEFILE; return do_sys_open(dfd, filename, flags, mode); } In that macro, the return is coming from do_sys_open. Now click on do_sys_open.\nThat will take you to the function definition on same file https://elixir.bootlin.com/linux/v6.5/source/fs/open.c#L1419\nlong do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode) { struct open_how how = build_open_how(flags, mode); return do_sys_openat2(dfd, filename, \u0026amp;how); } The function again returns another one called do_sys_openat2.\nIf you click on do_sys_openat2, you can see that there is no call to another function in the return statement.\nstatic long do_sys_openat2(int dfd, const char __user *filename, struct open_how *how) { struct open_flags op; int fd = build_open_flags(how, \u0026amp;op); struct filename *tmp; if (fd) return fd; tmp = getname(filename); if (IS_ERR(tmp)) return PTR_ERR(tmp); fd = get_unused_fd_flags(how-\u0026gt;flags); if (fd \u0026gt;= 0) { struct file *f = do_filp_open(dfd, tmp, \u0026amp;op); if (IS_ERR(f)) { put_unused_fd(fd); fd = PTR_ERR(f); } else { fd_install(fd, f); } } putname(tmp); return fd; } As a final step, we can check this function in kernel symbol table to make sure our module can access it.\nsudo grep -w do_sys_openat2 /proc/kallsyms Output:-\nffffffff8e2aadf0 t do_sys_openat2 Yes, it\u0026rsquo;s available. So we are good to use do_sys_openat2.\nSo this confirms that the function that kernel executes during syscall openat is do_sys_openat2!! ðŸŽ‰\nIf it\u0026rsquo;s too much to digest, you can comeback to this article later. There are tools made to make this steps easier and we will see those going forward.\n","date":"22 January 2024","permalink":"/posts/07-ebpf-for-linux-admins-part7/","section":"Posts","summary":"Let\u0026rsquo;s look at , kprobes.","title":"eBPF for Linux Admins: Part VII"},{"content":"","date":"22 January 2024","permalink":"/tags/kernel/","section":"Tags","summary":"","title":"kernel"},{"content":"","date":"22 January 2024","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"22 January 2024","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"ðŸŽ¤ Speaker at CNCG Kochi, DevOpsMalayalam and AWS Community Days Kochi.\nðŸ‘‰ My Talks\nðŸ‘‰ My Kubernetes Notes\n","date":"22 January 2024","permalink":"/","section":"Welcome to My Blog! ðŸŽ‰","summary":"ðŸŽ¤ Speaker at CNCG Kochi, DevOpsMalayalam and AWS Community Days Kochi.","title":"Welcome to My Blog! ðŸŽ‰"},{"content":"In the previous article, we wrote an eBPF program to block all packets via XDP.\nThis article is a continuation of previous artcle where we will block a TCP port of an interface instead of all packets.\nBut before we go forward, let\u0026rsquo;s expand the diagram we have see in the first article.\nThe BPF or pseudo VM has been enhanced by Alexei Starovoitov along with Daniel Borkmann.\nRegistres were increased from 3 to 11. Changed register to 64bit. Added a stack of 512 bytes Added unlimited arbitory key/value structure called maps Added helper function support Added a Verifier to verify code Added a JIT compiler to generate native assembly code from object code A simple firewall using eBPF # This eBPF program will will block traffic to port 80 of an interface.\n#include \u0026lt;linux/bpf.h\u0026gt; #include \u0026lt;bpf/bpf_helpers.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;linux/if_ether.h\u0026gt; #include \u0026lt;linux/ip.h\u0026gt; #include \u0026lt;linux/tcp.h\u0026gt; #define BLOCK_PORT 80 #define TOTSZ (sizeof(struct ethhdr) + sizeof(struct iphdr) + sizeof(struct tcphdr)) SEC(\u0026#34;xdp\u0026#34;) int xdp_drop_port(struct xdp_md *ctx) { void *data = (void *)(long)ctx-\u0026gt;data; void *data_end = (void *)(long)ctx-\u0026gt;data_end; // Set IP and TCP header structs struct iphdr *ip = data + sizeof(struct ethhdr); struct tcphdr *tcph = data + sizeof(struct ethhdr) + sizeof(struct iphdr); //Below check is made mandatoy by eBPF verifier if (data + TOTSZ \u0026gt; data_end) { return XDP_PASS; } // If its a TCP packet and destined to port 80, then drop iit if (ip-\u0026gt;protocol == IPPROTO_TCP \u0026amp;\u0026amp; tcph-\u0026gt;dest == htons(BLOCK_PORT)) { // Write debug info to /sys/kernel/debug/tracing/trace_pipe bpf_printk(\u0026#34;Blocking packet from %pI4 to port %u\\n\u0026#34;,\u0026amp;ip-\u0026gt;saddr, ntohs(tcph-\u0026gt;dest)); return XDP_DROP; } return XDP_PASS; } char _license[] SEC(\u0026#34;license\u0026#34;) = \u0026#34;GPL\u0026#34;; We are reading the start and end of data using xdp_md.\nWe have to make sure the headers + data is not greater than the end of the data. If we accedently read anything outside of the end, then that may crash the kernel and that is why the verifier enforces this check.\nOther details are self explanatory from the program itself.\nLet\u0026rsquo;s compile the program and then load it.\nclang -O2 -g -Wall -target bpf -c xdp_drop_port.c -o xdp_drop_port.o sudo xdp-loader load -m skb -s xdp enp0s8 xdp_drop_port.o Then you can watch the trace logs with below command\ncat /sys/kernel/debug/tracing/trace_pipe If you try to use curl command to the IP assigned to the interface enp0s8 then you will notice and output like below;\n\u0026lt;idle\u0026gt;-0 [003] ..s21 89616.096958: bpf_trace_printk: Blocking packet from 192.168.57.1 to port 80 \u0026lt;idle\u0026gt;-0 [003] ..s21 89617.123247: bpf_trace_printk: Blocking packet from 192.168.57.1 to port 80 \u0026lt;idle\u0026gt;-0 [003] ..s21 89619.139545: bpf_trace_printk: Blocking packet from 192.168.57.1 to port 80 Congratulations for making yourself to this stage!!.ðŸŽ‰ Give a pat on your shoulder ðŸ˜„\nSo far we have used eBPF in XDP. In upcoming one, we will use eBPF on kprobs. Brace yourself for the next eBPF chapters.\n","date":"18 January 2024","permalink":"/posts/05-ebpf-for-linux-admins-part5/","section":"Posts","summary":"In the previous article, we wrote an eBPF program to block all packets via XDP.","title":"eBPF for Linux Admins: Part V"},{"content":"In the previous articles, we were using skb to get details of a packet. This skb object is the kernel representation of a packet.\nDropping a packet after skb gets created is waste of CPU and memory. This can even have an impact during DDoS attempt.\nSo how can we drop a packet even before it reaches the stage of skb creation.\nHere we will use another hook point called XDP or eXpressDataPath. XDP is a high-performance, programmable packet processing framework within the Linux kernel that enables early packet handling before reaching the network stack.\nXDP Packet flow # The packets comes to the NIC. NIC places those packets to the RX_RING which is a circular ring buffer via DMA. When the buffer gets full, an interrupt is fired to CPU. Once the CPU get\u0026rsquo;s interrupted, the loaded NIC driver code gets executed. The driver code reads the packets from the queue. The initial path of packet after RX_RING is where we use XDP. Instead of writing our own module, we will write an eBPF program this time and then attach that to the the interface.\nThere are different ways to us XDP.\nGeneric XDP # XDP program loaded into the kernel as part of the network path.\nNative XDP # XDP program loaded by the driver in it\u0026rsquo;s initial recieve path\nOffloaded XDP # XDP program loads directly to the NIC and handled by the NIC controller.\nIn this article we will use Generic XDP since it doesn\u0026rsquo;t need support from NIC or it\u0026rsquo;s driver.\nOnce the packet is recieved by the XDP progra, it can do one of below;\nXDP_DROP : No processing, just drop the packet.\nXDP_PASS : Pass the packet to the next network stack component.\nXDP_TX : Forward the packet to the same network interface.\nXDP_REDIRECT : Froward the packet to another NIC and bypass all kernel network stack paths.\nAs I mentioned earlier, this is our gateway to eBPF so pay attention to this chapter.\nOur experiments will happen from an Ubuntu 23.10 VM running in VirtualBox.\nYou have been warned!!\nThe eBPF program we write will block all network in an interface. To compile eBPF programs, we need to install few tools.\nsudo apt install clang llvm libelf-dev libpcap-dev build-essential libbpf-dev linux-headers-$(uname -r) gcc-multilib #include \u0026lt;linux/bpf.h\u0026gt; #include \u0026lt;bpf/bpf_helpers.h\u0026gt; SEC(\u0026#34;xdp_drop\u0026#34;) int xdp_drop_prog(struct xdp_md *ctx) { return XDP_DROP; } char _license[] SEC(\u0026#34;license\u0026#34;) = \u0026#34;GPL\u0026#34;; Compile the program to bpf format.\neBPF is restricted to call only a list of kernel helper functions.\nUse man bpf-helpers command to get more details. clang -O2 -g -Wall -target bpf -c xdp_drop.c -o xdp_drop.o After compilation, we will get an eBPF file named xdp_drop.o.\nWe will be using the xdp-loader tool to load the xdp_drop.o program, so we need install xdp tools first.\nsudo apt-get install xdp-tools After installing the tool, check the loaded programs on the interfaces. As of now no programs were laoded!\nsudo xdp-loader status CURRENT XDP PROGRAM STATUS: Interface Prio Program name Mode ID Tag Chain actions -------------------------------------------------------------------------------------- lo \u0026lt;No XDP program loaded!\u0026gt; enp0s3 \u0026lt;No XDP program loaded!\u0026gt; enp0s8 \u0026lt;No XDP program loaded!\u0026gt; enp0s9 \u0026lt;No XDP program loaded!\u0026gt; Now load the program to one of the interface.\nsudo xdp-loader load -m skb -s xdp_drop enp0s8 xdp_drop.o Check the loaded progam on all interfaces.\nsudo xdp-loader status CURRENT XDP PROGRAM STATUS: Interface Prio Program name Mode ID Tag Chain actions -------------------------------------------------------------------------------------- lo \u0026lt;No XDP program loaded!\u0026gt; enp0s3 \u0026lt;No XDP program loaded!\u0026gt; enp0s8 xdp_dispatcher skb 117 90f686eb86991928 =\u0026gt; 50 xdp_drop_prog 126 57cd311f2e27366b XDP_PASS enp0s9 \u0026lt;No XDP program loaded!\u0026gt; That concludes part 4 of this eBPF series. In next one we will see how to block a port using eBPF in XDP.\n","date":"14 January 2024","permalink":"/posts/04-ebpf-for-linux-admins-part4/","section":"Posts","summary":"In the previous articles, we were using skb to get details of a packet.","title":"eBPF for Linux Admins: Part IV"},{"content":"In this article, we will write a kernel module that drops the incoming packets if it\u0026rsquo;s destined to port 80.\nYes, we can use iptables, but to learn the innerworkings of Linux, let\u0026rsquo;s come out of that confort zone and write our own one this time. Before we move forward, we have to familiarise more terms, which are Helper Functions and Hooks.\nHelper Functions # In the previous chapter, we wrote a simple module to print a message to the kernel ring buffer and there we used a helper function called, pr_info.\nSince the driver is in Kernel space, we couldn\u0026rsquo;t use any of the userpsace libraries to make log entries. So what we did was, we tooke the help of a kernel helper function. Linux helper functions are facilites that can be used to interact with other parts of the kernel. We will see more helper functions going forward.\nIn our hello example we used the helper function pr_info from header file \u0026lt;linux/printk.h\u0026gt;\nHooks # Hooks are pre-defined points in Kernel where you can register a function to it. When ever kernel reaches that hook, the registred function in that hook gets executed.\nLet\u0026rsquo;s see an example of hooks in netfilter. What is netfilter?\nIt\u0026rsquo;s your favorite iptables/nftable backend to filter/tralslate packets.\nThe netfilter hooks are a framework inside the Linux kernel that allows kernel modules to register callback functions at different locations of the Linux network stack. The registered callback function is then called back for every packet that traverses the respective hook within the Linux network stack. In above diagram, you can see different hook points and we will use the hook point PRE-ROUTING to drop a packet. So, we will write a module that will have a function; to be precise a callback function, to drop an IPv4 packet if the destination port is 80. Then that function will be registed to the PRE-ROUTING hook. When ever the kernel reaches the PRE-ROUTING hook point, our function will get executed and packet will be dropped.\nBut wait!!. Didn\u0026rsquo;t we start this series for learning eBPF? Yeah, I know, but please be patient. Things will get better going formward.\nA simple firewall module to drop packets to port 80 # mkdir -p netfilter/example cd !$ vi drop_pkt.c #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/ip.h\u0026gt; #include \u0026lt;linux/tcp.h\u0026gt; #include \u0026lt;linux/netfilter.h\u0026gt; #include \u0026lt;linux/netfilter_ipv4.h\u0026gt; #define BLOCK_PORT 80 // Callback function static unsigned int hook_func(void *priv, struct sk_buff *skb, const struct nf_hook_state *state) { // Access packet information using skb struct iphdr *iph = ip_hdr(skb); struct tcphdr *tcph = tcp_hdr(skb); if(ntohs(tcph-\u0026gt;dest) == BLOCK_PORT){ pr_info(\u0026#34;Blocking packet from %pI4 to port %u\\n\u0026#34;,\u0026amp;iph-\u0026gt;saddr, ntohs(tcph-\u0026gt;dest)); return NF_DROP; // Drop packets to port 80 } return NF_ACCEPT; // Allow the packet to continue } // Netfilter hook options static struct nf_hook_ops nf_hook_ops = { .hook = hook_func, // Our callback function .pf = PF_INET, // IPv4 protocol family .hooknum = NF_INET_PRE_ROUTING, // Hook point in the netfilter framework .priority = NF_IP_PRI_FIRST, // Invocation priority }; static int __init drop_pkt_module_init(void) { return nf_register_net_hook(\u0026amp;init_net, \u0026amp;nf_hook_ops); //init_net indicates the root network namespace } static void __exit drop_pkt_module_exit(void) { nf_unregister_net_hook(\u0026amp;init_net, \u0026amp;nf_hook_ops); } module_init(drop_pkt_module_init); module_exit(drop_pkt_module_exit); MODULE_LICENSE(\u0026#34;GPL\u0026#34;); Create a Makefile with below contnents.\nvi Makefile obj-m += drop_pkt.o PWD := $(CURDIR) all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean Now, you can start a simple HTTP server using python in a new terminal.\nsudo python3 -m http.server 80 Now try to access the port using curl command.\ncurl -sI 192.168.56.102 Output:-\nHTTP/1.0 200 OK Server: SimpleHTTP/0.6 Python/3.10.12 Date: Mon, 15 Jan 2024 17:38:36 GMT Content-type: text/html; charset=utf-8 Content-Length: 1218 Now, load the module.\ninsmod drop_pkt.ko Repeat the curl command again and this time the command will hung.\nIf you check the dmesg, you will see and output like below;\n... [98510.008817] Incoming packet from 192.168.56.1 to port 80 [98511.022603] Incoming packet from 192.168.56.1 to port 80 [98513.038433] Incoming packet from 192.168.56.1 to port 80 [98517.198138] Incoming packet from 192.168.56.1 to port 80 ... You can unload the module using below command and then curl command will work.\nsudo rmmod drop_pkt Now we are familier with how we can interact with different parts of the kernel using Kernel modules and some of the basics of hooks and helper functions.\nIn the next one, we will learn how we can inetract with the packets before the kernel create socket buffer or skb.\n","date":"5 January 2024","permalink":"/posts/03-ebpf-for-linux-admins-part3/","section":"Posts","summary":"In this article, we will write a kernel module that drops the incoming packets if it\u0026rsquo;s destined to port 80.","title":"eBPF for Linux Admins: Part III"},{"content":"You might be wondering, why we have to look at wrting kernel modules. The idea of kernel modules will help you to breakdown some of the key flexbilities in Linux kernel.\nPlease refer the book The Linux Kernel Module Programming Guide for more info. Its a FREE book. The Hello world module # This module will print messages to the kernel ring buffer (is special datastructure in kernel) and we can read those message using dmesg command.\nLet\u0026rsquo;s create a directory for our module and start writing our code.\nmkdir -p lkmpg/hello-world cd !$ vi hello.c Paste below contents to the editor and save it.\n/* * hello.c - The simplest kernel module. */ #include \u0026lt;linux/module.h\u0026gt; /* Needed by all modules */ #include \u0026lt;linux/printk.h\u0026gt; /* Needed for pr_info() */ int init_module(void) { pr_info(\u0026#34;Hello world 1.\\n\u0026#34;); /* A non 0 return means init_module failed; module can\u0026#39;t be loaded. */ return 0; } void cleanup_module(void) { pr_info(\u0026#34;Goodbye world 1.\\n\u0026#34;); } MODULE_LICENSE(\u0026#34;GPL\u0026#34;); Create a Makefile to compile the code.\nvi Makefile obj-m += hello.o PWD := $(CURDIR) all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean Now, let\u0026rsquo;s compile the code and load it.\nmake Output:-\nmake -C /lib/modules/6.2.0-39-generic/build M=/home/ansil/lkmpg/hello-world modules make[1]: Entering directory \u0026#39;/usr/src/linux-headers-6.2.0-39-generic\u0026#39; warning: the compiler differs from the one used to build the kernel The kernel was built by: x86_64-linux-gnu-gcc-11 (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0 You are using: gcc-11 (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0 CC [M] /home/ansil/lkmpg/hello-world/hello.o MODPOST /home/ansil/lkmpg/hello-world/Module.symvers CC [M] /home/ansil/lkmpg/hello-world/hello.mod.o LD [M] /home/ansil/lkmpg/hello-world/hello.ko BTF [M] /home/ansil/lkmpg/hello-world/hello.ko Skipping BTF generation for /home/ansil/lkmpg/hello-world/hello.ko due to unavailability of vmlinux make[1]: Leaving directory \u0026#39;/usr/src/linux-headers-6.2.0-39-generic\u0026#39; Load the module\nsudo insmod hello.ko Now execute dmesg command to see the output\nsudo dmesg | tail Output:-\n... [ 3544.575680] Hello world 1. ... Let\u0026rsquo;s unload the module and confirm the message again.\nList the loaded module lsmod | grep hello Unload the module sudo rmmod hello Now you can execute dmesg command again to verify the message.This time you can see the \u0026ldquo;Goodbye\u0026rdquo; message.\n... [ 3544.575680] Hello world 1. [10666.570524] Goodbye world 1. ... This covers the part II of the eBPF series. In next one we will write a kernel module to drop a packet.\n","date":"3 January 2024","permalink":"/posts/02-ebpf-for-linux-admins-part2/","section":"Posts","summary":"You might be wondering, why we have to look at wrting kernel modules.","title":"eBPF for Linux Admins: Part II"},{"content":" This article series is based on my journey to demystify eBPF. Pre-requisites # To get the most out of this article, it\u0026rsquo;s helpful to have some background in Linux networking and packet tracing with tcpdump. Some of the internals were intentionally excluded to simplify the topic.\nClassic BPF # Let\u0026rsquo;s take the scenario were you wanted to observe all ARP packet coming to the NIC. The packet first lands in the network device hardware and then later will be placed in an receive queue (RX_RING) inside the Kernel.\nFor a user to see ARP packets, packets needs to be copied from kernel space to the user space. Then each of the packets needs to be filtered based on its packet type; ARP.\nIf the system is going to copy all packets get\u0026rsquo;s into RX_RING to user space and then checking for a matching packet type, system have to do packet copy from kernel space to users pace. Switching CPU from kernel space to user space to copy packet is inefficient and will affect the system performance.\nSo how can we filter packets which are - on-the way - within the kernel space and copy only the matching packets to user space?\nHere comes the BPF or Berkley Packet Filter.\nThe BPF virtual machine is a pseudo VM inside the Linux kernel. For the sake of simplicity, you can consider this as a JavaScript engine inside your browser!\nOne of the tool in Linux that uses BPF is the tcpdump which utilises the BPF for packet filtering.\nThe BPF VM supports a limited set of instructions and there are many restrictions to the usage as well.\nBelow are the registers in BPF VM (or pseudo-machine)\nA 32bit wide accumulator [A] where the contents of the packet get loaded. A 32bit wide index register [X]. A scratch memory area of 16 32bit registers. A program counter. The filters we pass to tcpdump command will be converted into \u0026ldquo;byte code\u0026rdquo; and then injected directly into the kernel.(More about byte code will be coming later in this article.)\nThe load instructions loads the packet data to accumulator, and then we can examine the packets in BPF VM.\nLet\u0026rsquo;s examine the code generated by the tcpdump command that filters the ARP packets coming to interface ens33.\n[root@localhost ~]# tcpdump -i ens33 arp -d (000) ldh [12] (001) jeq #0x806 jt 2 jf 3 (002) ret #262144 (003) ret #0 [root@localhost ~]# Explanation\n(000) ldh - Load half word (16 bits) from index 12 of the packet ; skip 6 byte dst mac and 6 byte src mac. (001) jeq - If accumulator value is 0x806 ; ie ARP packet, then jump to 2 else jump to 3 (002) ret - Return the contents with buffer size 262144 ; ie entire packet or [max snapshot length](https://github.com/the-tcpdump-group/tcpdump/blob/tcpdump-4.9/netdissect.h#L263) (003) ret - Return nothing to the users pace You can find more details of the inner working of BPF in this Usenix paper\nSo the above filter skips the source and destination mac fields and then loads 16bits from the index 12 which is the packet type.\nSo the 16bits - 0x806 (0000100000000110) at offset 12 will try to match ARP packet!\nFew points to note;\nThe Ethernet type II packet have below format; Ethernet packets are big-endain.\nIn a 32bit system, a full word is 32bit, half word is 16bit.\n1 byte = 8bits, 2 byte = 16bits\nYou can find the Ethernet type hex representation of packet types in IANA\n------------------------------------------------------------------------------------------------------------------------------------------------ Ethertype (decimal) Ethertype (hex) Exp. Ethernet (decimal) Exp. Ethernet (octal) Description Reference ------------------------------------------------------------------------------------------------------------------------------------------------ 2054 0806 - - Address Resolution Protocol (ARP) [RFC7042] ------------------------------------------------------------------------------------------------------------------------------------------------ The Byte Code # The BPF program we discussed above can be converted to byte code.\nWhat is byte code?\nA compact, platform-independent instruction set designed for execution by a virtual machine, rather than directly by a physical CPU. In this case the VM is a BPF pseudo VM sitting inside the Kernel.\nThe user space can inject this bytecode to the BPF pseudo VM and the VM will convert that to the architecture dependant assembly code which can be executed directly on the hardware.\nWe can generate the bytecode of the BPF instruction in tcpdump itself.\n[root@localhost ~]# tcpdump -i ens33 arp -ddd 4 40 0 0 12 21 0 1 2054 6 0 0 262144 6 0 0 0 The bytecode can be injected into the system in different ways. The tcmpdump utility have it\u0026rsquo;s own logic to do this operation.\nWith that we concludes the Part - 1 of eBPF for Linux Admins here.\nIn the next part, we will discuss eXpressDataPath - XDP and eBPF.\n","date":"1 January 2024","permalink":"/posts/01-ebpf-for-linux-admins-part1/","section":"Posts","summary":"This article series is based on my journey to demystify eBPF.","title":"eBPF for Linux Admins: Part I"},{"content":" Here goes all the articles I\u0026rsquo;ve published so far.. ","date":"23 December 2023","permalink":"/posts/","section":"Posts","summary":"Here goes all the articles I\u0026rsquo;ve published so far.","title":"Posts"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]